---
layout: post
author: joonwan jeon
tags: [operating system]
category: operating system
---

# 1. I/O 란?

![](/assets/images/os/io.png)

IO 란 computer 에 data 가 들어가고 나오는 작업을 의미합니다. IO 작업은 Computer 의 CPU 가 직접 작업하지 않고 io 장치의 Device controller 에게 작업을 위입합니다.

# 2. I/O 를 수행하는 방법

IO 를 수행하는 방법은 **관점에 따라** 두가지로 나눌 수 있습니다. 
첫 번째 방법은 **io 완료를 기다리는 방식**에 따른 분류로, 동기식 입출력과 비동기식 입출력이 있습니다. 두 번째 관점은 **io 장치에 접근하는 방식**에 따른 분류로 이는 2.2 절에서 다루겠습니다.

## 2.1 I/O 완료를 기다리는 방식 - 동기 & 비동기 

### 2.1.1 동기식 입출력 - Synchronous I/O

동기식 입출력는 **IO 요청 후 작업이 완료될때 까지 기다렸다가** 제어권을 돌려받는 방식입니다. 예를 들어 디스크에서 파일을 읽는 **read()** system call 을 호출하면, 데이터를 완전히 읽을 때 까지 프로세스는 다음 코드로 진행할 수 없습니다.

이를 구현하는 방법은 다음 두가지 입니다.

1. io 가 끝날때 까지 cpu 를 낭비 (공회전) 시키는 방법
- io 가 끝날 때 까지 cpu 가 아무 일도 하지 않고 계속 확인만 합니다 (polling)
- 매우 비효율적인 방법입니다. cpu가 낭비되며, 동시에 하나의 io 작업만 처리 가능합니다.
- 거의 사용되지 않는 방법입니다.

2. 프로세스를 대기상태로 전환시키는 방법
- 가장 일반적인 방법입니다.
- io 를 요청한 프로세스를 **BLOCKED(대기) 상태** 로 만들고 대기 큐에 넣습니다.
- 다른 프로세스가 cpu 를 사용할 수 있어 cpu 활용률이 높아집니다.
- io 작업 완료시 interrupt 가 발생하고, 프로세는 **READY** 상태가 됩니다. 


### 2.1.2 비동기식 입출력 - Asynchronous I/O
- io 를 요청한 즉시 제어권이 해당 사용자 프로세스에게 반환되어 다음 다른 작업을 계속할 수 있는 방식입니다.
- io 가 **백그라운드에서 진행**되는 동안 프로세스는 다른 작업을 수행합니다.

> [!TIP]
> synchronous io 와 asynchronous io 모두 io 완료를 알리기 위해 **interrupt**를 사용합니다. 
> 차이점은 **프로세스가 io 완료를 기다리느냐** 입니다.

## 2.2 IO 장치 접근 방식: I/O Instruction vs Memory-Mapped I/O

이번 절에서는 **cpu 가 io 장치에 접근하는 방식**에 따라 두가지 방법을 살펴보겠습니다.

### 2.2.1 I/O Instruction 방식 (특수 명령어 방식)

![](/assets/images/os/io_instruction_memory.png)

- 메모리 접근과 IO 장치 접근을 별도의 명령어로 구분하는 방식입니다.
- 메모리는 **Memory Address** 를 사용합니다.
- io 장치는 **Device Address** 를 사용합니다.
- 메모리와 io 장치가 명확히 구분됩니다. 따라서 보안상 안전합니다.
- 하지만 별도의 io 명령어가 필요하기때문에 명령어 집합이 복잡해집니다.

### 2.2.2 Memory-Mapped I/O 방식

![](/assets/images/os/memory_mapped.png)
- io 장치에 **메모리 주소를 할당**하는 방식입니다.
- 매모리 접근 명령어로 **IO 장치도 접근** 가능합니다.
- 하나의 통일된 주소 공간을 사용합니다.
- 별도의 IO 명령어가 불필요하고 메모리 접근 기법을 모두 활용가능합니다.
- 또한 pointer 연산으로 io 제어가 가능힙내다.
- 하지만 메모리 주소 공간 일부를 io 에 할당해야하기 때문에 실제 가용 메모리 용량이 감소합니다.